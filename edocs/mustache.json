{
  "edoc__id": "mustache", 
  "edoc_couchapp": {
    "manifest": [
      "env.json", 
      "js_module.js"
    ], 
    "objects": {}, 
    "signatures": {}
  }, 
  "env": {
    "page": {
      "name": "mustache", 
      "title": "Mustache"
    }, 
    "script": {
      "commonjs": "js_module"
    }
  }, 
  "js_module": "/*\n * CommonJS-compatible mustache.js module\n *\n * See http://github.com/janl/mustache.js for more info.\n */\n\n/*\n  mustache.js \u2014 Logic-less templates in JavaScript\n\n  See http://mustache.github.com/ for more info.\n*/\n\nvar Mustache = function() {\n  var Renderer = function() {};\n\n  Renderer.prototype = {\n    otag: \"{{\",\n    ctag: \"}}\",\n    pragmas: {},\n    buffer: [],\n    pragmas_implemented: {\n      \"IMPLICIT-ITERATOR\": true,\n      \"TRANSLATION-HINT\": true\n    },\n    context: {},\n\n    render: function(template, context, partials, in_recursion) {\n      // reset buffer & set context\n      if(!in_recursion) {\n        this.context = context;\n        this.buffer = []; // TODO: make this non-lazy\n      }\n\n      // fail fast\n      if(!this.includes(\"\", template)) {\n        if(in_recursion) {\n          return template;\n        } else {\n          this.send(template);\n          return;\n        }\n      }\n\n      // Branching or moving down the partial stack, save any translation mode info.\n      if (this.pragmas['TRANSLATION-HINT']) {\n        context['_TRANSLATION-HINT_mode'] = this.pragmas['TRANSLATION-HINT'].mode;\n      }\n\n      // get the pragmas together\n      template = this.render_pragmas(template);\n\n      // handle all translations\n      template = this.render_i18n(template, context, partials);\n\n      // render the template\n      var html = this.render_section(template, context, partials);\n\n      // render_section did not find any sections, we still need to render the tags\n      if (html === false) {\n        html = this.render_tags(template, context, partials, in_recursion);\n      }\n\n      if (in_recursion) {\n        return html;\n      } else {\n        this.sendLines(html);\n      }\n    },\n\n    /*\n      Sends parsed lines\n    */\n    send: function(line) {\n      if(line != \"\") {\n        this.buffer.push(line);\n      }\n    },\n\n    sendLines: function(text) {\n      if (text) {\n        var lines = text.split(\"\\n\");\n        for (var i = 0; i < lines.length; i++) {\n          this.send(lines[i]);\n        }\n      }\n    },\n\n    /*\n      Looks for %PRAGMAS\n    */\n    render_pragmas: function(template) {\n      // no pragmas\n      if(!this.includes(\"%\", template)) {\n        return template;\n      }\n\n      var that = this;\n      var regex = new RegExp(this.otag + \"%([\\\\w-]+) ?([\\\\w]+=[\\\\w]+)?\" +\n            this.ctag);\n      return template.replace(regex, function(match, pragma, options) {\n        if(!that.pragmas_implemented[pragma]) {\n          throw({message:\n            \"This implementation of mustache doesn't understand the '\" +\n            pragma + \"' pragma\"});\n        }\n        that.pragmas[pragma] = {};\n        if(options) {\n          var opts = options.split(\"=\");\n          that.pragmas[pragma][opts[0]] = opts[1];\n        }\n        return \"\";\n        // ignore unknown pragmas silently\n      });\n    },\n\n    /*\n      Tries to find a partial in the curent scope and render it\n    */\n    render_partial: function(name, context, partials) {\n      name = this.trim(name);\n      if(!partials || partials[name] === undefined) {\n        throw({message: \"unknown_partial '\" + name + \"'\"});\n      }\n      if(typeof(context[name]) != \"object\") {\n        return this.render(partials[name], context, partials, true);\n      }\n      return this.render(partials[name], context[name], partials, true);\n    },\n\n    render_i18n: function(html, context, partials) {\n      if (html.indexOf(this.otag + \"_i\") == -1) {\n        return html;\n      }\n      var that = this;\n      var regex = new RegExp(this.otag + \"\\\\_i\" + this.ctag +\n        \"\\\\s*([\\\\s\\\\S]+?)\" + this.otag + \"\\\\/i\" + this.ctag, \"mg\");\n\n      // for each {{_i}}{{/i}} section do...\n      return html.replace(regex, function(match, content) {\n        var translationMode;\n\n        if (that.pragmas && that.pragmas[\"TRANSLATION-HINT\"] && that.pragmas[\"TRANSLATION-HINT\"].mode) {\n          translationMode = that.pragmas[\"TRANSLATION-HINT\"].mode;\n        } else if (context['_TRANSLATION-HINT_mode']) {\n          translationMode = context['_TRANSLATION-HINT_mode'];\n        }\n\n        var params = content;\n\n        if (translationMode) {\n          params = {\n            text: content,\n            mode: translationMode\n          };\n        }\n\n        return _(params);\n      });\n    },\n\n    /*\n      Renders inverted (^) and normal (#) sections\n    */\n    render_section: function(template, context, partials) {\n      if(!this.includes(\"#\", template) && !this.includes(\"^\", template)) {\n        // did not render anything, there were no sections\n        return false;\n      }\n\n      var that = this;\n\n      // This regex matches _the first_ section ({{#foo}}{{/foo}}), and captures the remainder\n      var regex = new RegExp(\n        \"^([\\\\s\\\\S]*?)\" +         // all the crap at the beginning that is not {{*}} ($1)\n\n        this.otag +               // {{\n        \"(\\\\^|\\\\#)\\\\s*(.+)\\\\s*\" + //  #foo (# == $2, foo == $3)\n        this.ctag +               // }}\n\n        \"\\n*([\\\\s\\\\S]*?)\" +       // between the tag ($2). leading newlines are dropped\n\n        this.otag +               // {{\n        \"\\\\/\\\\s*\\\\3\\\\s*\" +        //  /foo (backreference to the opening tag).\n        this.ctag +               // }}\n\n        \"\\\\s*([\\\\s\\\\S]*)$\",       // everything else in the string ($4). leading whitespace is dropped.\n\n      \"g\");\n\n      // for each {{#foo}}{{/foo}} section do...\n      return template.replace(regex, function(match, before, type, name, content, after) {\n        // before contains only tags, no sections\n        var renderedBefore = before ? that.render_tags(before, context, partials, true) : \"\",\n\n        // after may contain both sections and tags, so use full rendering function\n            renderedAfter = after ? that.render(after, context, partials, true) : \"\",\n\n        // will be computed below\n            renderedContent,\n\n            value = that.find(name, context);\n\n        if (type === \"^\") { // inverted section\n          if (!value || that.is_array(value) && value.length === 0) {\n            // false or empty list, render it\n            renderedContent = that.render(content, context, partials, true);\n          } else {\n            renderedContent = \"\";\n          }\n        } else if (type === \"#\") { // normal section\n          if (that.is_array(value)) { // Enumerable, Let's loop!\n            renderedContent = that.map(value, function(row) {\n              return that.render(content, that.create_context(row), partials, true);\n            }).join(\"\");\n          } else if (that.is_object(value)) { // Object, Use it as subcontext!\n            renderedContent = that.render(content, that.create_context(value),\n              partials, true);\n          } else if (typeof value === \"function\") {\n            // higher order section\n            renderedContent = value.call(context, content, function(text) {\n              return that.render(text, context, partials, true);\n            });\n          } else if (value) { // boolean section\n            renderedContent = that.render(content, context, partials, true);\n          } else {\n            renderedContent = \"\";\n          }\n        }\n\n        return renderedBefore + renderedContent + renderedAfter;\n      });\n    },\n\n    /*\n      Replace {{foo}} and friends with values from our view\n    */\n    render_tags: function(template, context, partials, in_recursion) {\n      // tit for tat\n      var that = this;\n\n      var new_regex = function() {\n        return new RegExp(that.otag + \"(=|!|>|\\\\{|%)?([^\\\\/#\\\\^]+?)\\\\1?\" +\n          that.ctag + \"+\", \"g\");\n      };\n\n      var regex = new_regex();\n      var tag_replace_callback = function(match, operator, name) {\n        switch(operator) {\n        case \"!\": // ignore comments\n          return \"\";\n        case \"=\": // set new delimiters, rebuild the replace regexp\n          that.set_delimiters(name);\n          regex = new_regex();\n          return \"\";\n        case \">\": // render partial\n          return that.render_partial(name, context, partials);\n        case \"{\": // the triple mustache is unescaped\n          return that.find(name, context);\n        default: // escape the value\n          return that.escape(that.find(name, context));\n        }\n      };\n      var lines = template.split(\"\\n\");\n      for(var i = 0; i < lines.length; i++) {\n        lines[i] = lines[i].replace(regex, tag_replace_callback, this);\n        if(!in_recursion) {\n          this.send(lines[i]);\n        }\n      }\n\n      if(in_recursion) {\n        return lines.join(\"\\n\");\n      }\n    },\n\n    set_delimiters: function(delimiters) {\n      var dels = delimiters.split(\" \");\n      this.otag = this.escape_regex(dels[0]);\n      this.ctag = this.escape_regex(dels[1]);\n    },\n\n    escape_regex: function(text) {\n      // thank you Simon Willison\n      if(!arguments.callee.sRE) {\n        var specials = [\n          '/', '.', '*', '+', '?', '|',\n          '(', ')', '[', ']', '{', '}', '\\\\'\n        ];\n        arguments.callee.sRE = new RegExp(\n          '(\\\\' + specials.join('|\\\\') + ')', 'g'\n        );\n      }\n      return text.replace(arguments.callee.sRE, '\\\\$1');\n    },\n\n    /*\n      find `name` in current `context`. That is find me a value\n      from the view object\n    */\n    find: function(name, context) {\n      name = this.trim(name);\n\n      // Checks whether a value is thruthy or false or 0\n      function is_kinda_truthy(bool) {\n        return bool === false || bool === 0 || bool;\n      }\n\n      var value;\n      if(is_kinda_truthy(context[name])) {\n        value = context[name];\n      } else if(is_kinda_truthy(this.context[name])) {\n        value = this.context[name];\n      }\n\n      if(typeof value === \"function\") {\n        return value.apply(context);\n      }\n      if(value !== undefined) {\n        return value;\n      }\n      // silently ignore unkown variables\n      return \"\";\n    },\n\n    // Utility methods\n\n    /* includes tag */\n    includes: function(needle, haystack) {\n      return haystack.indexOf(this.otag + needle) != -1;\n    },\n\n    /*\n      Does away with nasty characters\n    */\n    escape: function(s) {\n      s = String(s === null ? \"\" : s);\n      return s.replace(/&(?!\\w+;)|[\"'<>\\\\]/g, function(s) {\n        switch(s) {\n        case \"&\": return \"&amp;\";\n        case \"\\\\\": return \"\\\\\\\\\";\n        case '\"': return '&quot;';\n        case \"'\": return '&#39;';\n        case \"<\": return \"&lt;\";\n        case \">\": return \"&gt;\";\n        default: return s;\n        }\n      });\n    },\n\n    // by @langalex, support for arrays of strings\n    create_context: function(_context) {\n      if(this.is_object(_context)) {\n        return _context;\n      } else {\n        var iterator = \".\";\n        if(this.pragmas[\"IMPLICIT-ITERATOR\"]) {\n          iterator = this.pragmas[\"IMPLICIT-ITERATOR\"].iterator;\n        }\n        var ctx = {};\n        ctx[iterator] = _context;\n        return ctx;\n      }\n    },\n\n    is_object: function(a) {\n      return a && typeof a == \"object\";\n    },\n\n    is_array: function(a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n\n    /*\n      Gets rid of leading and trailing whitespace\n    */\n    trim: function(s) {\n      return s.replace(/^\\s*|\\s*$/g, \"\");\n    },\n\n    /*\n      Why, why, why? Because IE. Cry, cry cry.\n    */\n    map: function(array, fn) {\n      if (typeof array.map == \"function\") {\n        return array.map(fn);\n      } else {\n        var r = [];\n        var l = array.length;\n        for(var i = 0; i < l; i++) {\n          r.push(fn(array[i]));\n        }\n        return r;\n      }\n    }\n  };\n\n  return({\n    name: \"mustache.js\",\n    version: \"0.3.1-dev-twitter\",\n\n    /*\n      Turns a template and view into HTML\n    */\n    to_html: function(template, view, partials, send_fun) {\n      var renderer = new Renderer();\n      if(send_fun) {\n        renderer.send = send_fun;\n      }\n      renderer.render(template, view || {}, partials);\n      if(!send_fun) {\n        return renderer.buffer.join(\"\\n\");\n      }\n    }\n  });\n}();\n\nexports.name = Mustache.name;\nexports.version = Mustache.version;\n\nexports.to_html = function() {\n  return Mustache.to_html.apply(this, arguments);\n};"
}